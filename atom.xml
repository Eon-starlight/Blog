<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://eon-starlight.github.io/Blog/</id>
    <title>Eon_Starlight&apos;s blog</title>
    <updated>2020-03-29T11:59:13.579Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://eon-starlight.github.io/Blog/"/>
    <link rel="self" href="https://eon-starlight.github.io/Blog/atom.xml"/>
    <subtitle>杀不死你的，终会使你更强大</subtitle>
    <logo>https://eon-starlight.github.io/Blog/images/avatar.png</logo>
    <icon>https://eon-starlight.github.io/Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Eon_Starlight&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[ 高精度基本乘法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-cheng-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-cheng-fa-bi-ji/">
        </link>
        <updated>2020-03-29T11:55:17.000Z</updated>
        <content type="html"><![CDATA[<h5 id="稍微不好理解一点">稍微不好理解一点</h5>
<ul>
<li>不包括小数、负数</li>
<li>
<h4 id="读入"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">读入</a></h4>
</li>
<li>先看一个例子：356和12相乘：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/eqbva1jk.png" alt="QAQ" loading="lazy"></li>
<li>由此发现：第i位与第j位相乘，乘积加到第i*j-1位。</li>
<li>这时候就需要进位了，我们模拟一下进位过程，需要从低位到高位：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/5rcm8gw4.png" alt="QAQ" loading="lazy"></li>
<li>then<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/vf5odps2.png" alt="QAQ" loading="lazy"></li>
<li>finally<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/mzsfza4e.png" alt="QAQ" loading="lazy"></li>
<li>这就是整体思路：计算+进位，这种逻辑仔细想想是可行的因为计算时进位最多进8（因为是乘法），进位到i位最多是9再加上最后维护进位时的1最多到18，不会存在多次进位。<br>
代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=1;i&lt;=ax.size();i++)
{
	for(int j=1;j&lt;=bx.size();j++)
	{
		ans[i+j-1]+=(a[i]*b[j])%10;
		ans[i+j]+=(a[i]*b[j])/10;
	}
}//计算不解释
asl=ax.size()*bx.size();//ans长度最大值
while(ans[asl]==0)asl--;//找出ans没进位前长度（进位后也最大多1位）
for(int i=1;i&lt;=asl;i++)
{
	if(i==asl&amp;&amp;ans[i]&gt;=10)//特判，如果最后一位要进位需要加长asl（ans长度）
	{
		ans[i+1]+=ans[i]/10;
		ans[i]%=10;
		asl++;
		break;
	}
	if(ans[i]&gt;=10)
	{
		ans[i+1]+=ans[i]/10;
		ans[i]%=10;
	}
}
</code></pre>
<ul>
<li>
<h4 id="输出"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">输出</a></h4>
</li>
<li>贴完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[2001],b[2001],ans[4000001],pd,asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=ax.size();i++)
	{
		for(int j=1;j&lt;=bx.size();j++)
		{
			ans[i+j-1]+=(a[i]*b[j])%10;
			ans[i+j]+=(a[i]*b[j])/10;
		}
	}
	asl=ax.size()*bx.size();
	while(ans[asl]==0)asl--;
	for(int i=1;i&lt;=asl;i++)
	{
		if(i==asl&amp;&amp;ans[i]&gt;=10)
		{
			ans[i+1]+=ans[i]/10;
			ans[i]%=10;
			asl++;
			break;
		}
		if(ans[i]&gt;=10)
		{
			ans[i+1]+=ans[i]/10;
			ans[i]%=10;
		}
	}
	for(int i=asl;i&gt;=1;i--)printf(&quot;%d&quot;,ans[i]);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 高精度基本减法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jian-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jian-fa-bi-ji/">
        </link>
        <updated>2020-03-29T10:18:50.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>不包括负数、小数（但可以输出负数）</li>
<li>
<h4 id="读入"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">读入</a></h4>
</li>
<li>因为第二个数有可能比第一个数大，也就是有负数答案，所以我们需要判断一下是否是这样的情况。代码实现；</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
if((ax&lt;bx&amp;&amp;ax.size()==bx.size())||ax.size()&lt;bx.size())//判断
{
	swap(ax,bx);
	pd=1;
}
for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
//思路就是把a-b变成-(b-a),pd=1代表这种情况，pd=0就不是
</code></pre>
<ul>
<li>整体思路与高精度加法差不多，都是依据小学数学进行模拟</li>
<li>
<h4 id="高精度加法链接"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/">高精度加法链接</a></h4>
</li>
<li>具体见代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=1;i&lt;=max(ax.size(),bx.size());i++)
{
	if(a[i]&lt;b[i])
	{
		a[i+1]--;//向高位借位，这个绝不能放在ans上跟高精加法的原因一样。
		a[i]+=10;//借过来的位
	}
	ans[i]=a[i]-b[i];
}
</code></pre>
<ul>
<li>然后要计算答案长度，跟高精加法差不多：</li>
</ul>
<pre><code class="language-cpp">asl=max(ax.size(),bx.size());
while(ans[asl]==0)asl--;
</code></pre>
<ul>
<li>输出需要看一下pd，是否输出负号，所以要加一句代码：</li>
</ul>
<pre><code class="language-cpp">if(pd==1)printf(&quot;-&quot;);
</code></pre>
<ul>
<li>
<h4 id="输出"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">输出</a></h4>
</li>
<li>最后在输出之后要特判一下，bug原因：</li>
</ul>
<pre><code class="language-cpp">if(asl&lt;1)printf(&quot;0&quot;);
</code></pre>
<ul>
<li>完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;//万能库
using namespace std;
int a[10087],b[10087],ans[10087],pd,asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	if((ax&lt;bx&amp;&amp;ax.size()==bx.size())||ax.size()&lt;bx.size())
	{
		swap(ax,bx);
		pd=1;
	}
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=max(ax.size(),bx.size());i++)
	{
		if(a[i]&lt;b[i])
		{
			a[i+1]--;
			a[i]+=10;
		}
		ans[i]=a[i]-b[i];
	}
	asl=max(ax.size(),bx.size());
	while(ans[asl]==0)asl--;
	if(pd==1)printf(&quot;-&quot;);
	for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
	if(asl&lt;1)printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度基本加法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/">
        </link>
        <updated>2020-02-26T05:13:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>不包括负数、小数</li>
<li>
<h4 id="读入"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">读入</a></h4>
</li>
<li>首先以15463和23521为例数来进行模拟加法，如下图<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/llfbhk54.png" alt="QAQ" loading="lazy"></li>
<li>由此可见，每一位与每一位直接相加传进答案，也就是：</li>
</ul>
<pre><code class="language-cpp">ans[i]=a[i]+b[i];
//代码实现
</code></pre>
<h2 id="但是这没有考虑进位qaq">但是这没有考虑进位！！QAQ</h2>
<ul>
<li>那要怎么解决呢？可以根据小学知识来看把进的位加到下一位，就是低位-10，高位+10，代码实现：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	ans[i+1]++;
	a[i]-=10;//不用担心变成负数，加上b[i]总会≥0
}
ans[i]+=a[i]+b[i];
//这是对第i位的处理
</code></pre>
<ul>
<li>
<h3 id="注意进的位加到ans数组上了正常来说这不对会有解释">注意进的位加到ans数组上了，正常来说这不对，会有解释。</h3>
</li>
<li>我们再举个例子13425和15718：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/6k5jlze9.png" alt="QAQ" loading="lazy"></li>
<li>
<h3 id="在这个时候会出现问题举个例子就明白了">在这个时候会出现问题，举个例子就明白了。</h3>
</li>
<li>15555和14545：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/h1f46plz.png" alt="QAQ" loading="lazy"></li>
<li>因为我们把进的一位加到ans数组上了，然而我们无法判断ans[i]是否要进位，所以就出现了这种情况。</li>
<li>为了避免这种情况我们进的位加到a数组里见代码：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	a[i+1]++;
	a[i]-=10;
}
ans[i]+=a[i]+b[i];
</code></pre>
<ul>
<li>这就是正确的计算过程。为了方便输出我们要算出答案的长度，长度最低为asl=max(ax.size(),bx.size);（输入的ax和bx）。因为有进位的可能所以我们要维护一下：</li>
</ul>
<pre><code class="language-cpp">while(ans[asl]!=0)asl++;
//就是枚举到最高位
asl--;
//但是这样会多出来1，就减掉
</code></pre>
<ul>
<li>
<h4 id="输出"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">输出</a></h4>
</li>
<li>完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;//万能库
using namespace std;
int a[1000001],b[1000001],ans[1000001],asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=max(ax.size(),bx.size())+1;i++)
	{
	    if(a[i]+b[i]&gt;=10)
	    {
	        a[i+1]++;
	        a[i]-=10;
	    }
	    ans[i]+=a[i]+b[i];
	}
	asl=max(ax.size(),bx.size())+1;
	while(ans[asl]!=0)asl++;
	asl--;
	for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度输出【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">
        </link>
        <updated>2020-02-26T05:05:43.000Z</updated>
        <content type="html"><![CDATA[<h4 id="高精度基本算法的通用输出">高精度基本算法的通用输出</h4>
<h5 id="非常的简单鸭">非常的简单鸭</h5>
<ul>
<li>假如我们的答案是12345，我们在ans数组里存它的时候就是这个样子：<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582693567222.png" alt="" loading="lazy"></li>
<li>所以我们要从ans[5]位向ans[1]位进行输出，在计算时我们已经求出了答案长度asl，这里asl=5，输出代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
</code></pre>
<ul>
<li>结束</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eon_Starlight]]></title>
        <id>https://eon-starlight.github.io/Blog/eon-de-keng/</id>
        <link href="https://eon-starlight.github.io/Blog/eon-de-keng/">
        </link>
        <updated>2020-02-25T11:45:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://eon-starlight.github.io/Blog//post-images/1582631686318.png" alt="" loading="lazy"></figure>
<h1 id="游荡于oi界于柴圈">游荡于oi界于柴圈……</h1>
<h1 id="一名蒻得很的蒟蒻">一名蒻得很的蒟蒻</h1>
<h1 id="菜是原罪啥都不会">菜是原罪，啥都不会</h1>
<p><img src="https://eon-starlight.github.io/Blog//post-images/1582631744762.png" alt="" loading="lazy"><br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582631753259.png" alt="" loading="lazy"><br>
###链接区域<br>
<a href="https://www.bilibili.com/"><img src="https://eon-starlight.github.io/Blog//post-images/1582675935541.png" alt="" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度读入【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">
        </link>
        <updated>2020-02-25T11:06:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="高精度基本算法的通用读入">高精度基本算法的通用读入</h3>
<ul>
<li>在普通实数变量型无法实现大数据运算时，我们会采用高精度来实现计算，我们利用数组来存一个数。要存多大的数就开多大的数组，因为我们用数组的每一个空间来存每一位数的那个数字。</li>
<li>假如要存12345这个数，要把它放进a[6]数组.我们把5放进a[1]，4放进a[2]，…，1放进a[5]。如下：</li>
</ul>
<pre><code class="language-cpp">a[1]=5;
a[2]=4;
a[3]=3
a[4]=2;
a[5]=1;
//现在a数组变成了{5,4,3,2,1}，a[i]就表示第i位
</code></pre>
<ul>
<li>我们不会把数字一位一位读入，而是选择用字符串一口气读入，然后就可以知道长度（.size()）就可以用for循环将字符串转成数组。</li>
<li>先度入：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
</code></pre>
<ul>
<li>然后这理解释一下字符串如何转数组。这里就以12345为例，先看一下代码：</li>
</ul>
<pre><code class="language-cpp">	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
<ul>
<li>为什么要这么写，我们来模拟一下。</li>
<li>首先i=ax.size()也就是五，然后将ax[ax.size-1]也就是ax[1]放进a[i]，具体怎么将字符转成数字百度一下，这里不解释了…<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629115230.png" alt="" loading="lazy"></li>
<li>i=4的情况<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629127550.png" alt="" loading="lazy"></li>
<li>3<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629136157.png" alt="" loading="lazy"></li>
<li>2<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629158832.png" alt="" loading="lazy"></li>
<li>1，像这样大家就应该明白了，已经很清晰了。<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629172963.png" alt="" loading="lazy"></li>
<li>读入就是这样，代码：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
]]></content>
    </entry>
</feed>
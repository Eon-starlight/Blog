<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://eon-starlight.github.io/Blog/</id>
    <title>Eon_Starlight&apos;s blog</title>
    <updated>2020-02-26T05:20:14.269Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://eon-starlight.github.io/Blog/"/>
    <link rel="self" href="https://eon-starlight.github.io/Blog/atom.xml"/>
    <subtitle>杀不死你的，终会使你更强大</subtitle>
    <logo>https://eon-starlight.github.io/Blog/images/avatar.png</logo>
    <icon>https://eon-starlight.github.io/Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Eon_Starlight&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[高精度基本加法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/">
        </link>
        <updated>2020-02-26T05:13:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>不包括负数、小数</li>
<li><a href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><menclose mathbackground="white"><mtext>读入</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\colorbox{white}{读入}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:red;height:1.2833299999999999em;background-color:white;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:red;"><span class="mord cjk_fallback" style="color:red;">读</span><span class="mord cjk_fallback" style="color:red;">入</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></li>
<li>首先以15463和23521为例数来进行模拟加法，如下图</li>
<li><img src="https://eon-starlight.github.io/Blog//post-images/1582694109293.png" alt="" loading="lazy"></li>
<li>由此可见，每一位与每一位直接相加传进答案，也就是：</li>
</ul>
<pre><code class="language-cpp">ans[i]=a[i]+b[i];
//代码实现
</code></pre>
<h2 id="但是这没有考虑进位qaq">但是这没有考虑进位！！QAQ</h2>
<ul>
<li>那要怎么解决呢？可以根据小学知识来看把进的位加到下一位，就是低位-10，高位+10，代码实现：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	ans[i+1]++;
	a[i]-=10;//不用担心变成负数，加上b[i]总会≥0
}
ans[i]+=a[i]+b[i];
//这是对第i位的处理
</code></pre>
<ul>
<li>
<h3 id="注意进的位加到ans数组上了正常来说这不对会有解释">注意进的位加到ans数组上了，正常来说这不对，会有解释。</h3>
</li>
<li>我们再举个例子13425和15718：<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582694117940.png" alt="" loading="lazy"></li>
<li>
<h3 id="在这个时候会出现问题举个例子就明白了">在这个时候会出现问题，举个例子就明白了。</h3>
</li>
<li>15555和14545：<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582694123657.png" alt="" loading="lazy"></li>
<li>因为我们把进的一位加到ans数组上了，然而我们无法判断ans[i]是否要进位，所以就出现了这种情况。</li>
<li>为了避免这种情况我们进的位加到a数组里见代码：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	a[i+1]++;
	a[i]-=10;
}
ans[i]+=a[i]+b[i];
</code></pre>
<ul>
<li>这就是正确的计算过程。为了方便输出我们要算出答案的长度，长度最低为asl=max(ax.size(),bx.size);（输入的ax和bx）。因为有进位的可能所以我们要维护一下：</li>
</ul>
<pre><code class="language-cpp">while(ans[asl]!=0)asl++;
//就是枚举到最高位
asl--;
//但是这样会多出来1，就减掉
</code></pre>
<ul>
<li>
<h4 id="colorredcolorboxwhite输出"><a href="https://www.luogu.com.cn/blog/yx20070829/gao-jing-du-shu-chu-bi-ji-post"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><menclose mathbackground="white"><mtext>输出</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\colorbox{white}{输出}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:red;height:1.2833299999999999em;background-color:white;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:red;"><span class="mord cjk_fallback" style="color:red;">输</span><span class="mord cjk_fallback" style="color:red;">出</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></h4>
</li>
<li>完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
#include&lt;limits&gt;
#include&lt;climits&gt;
#include&lt;cfloat&gt;
#include&lt;cstdlib&gt;
#include&lt;cwchar&gt;
#include&lt;ctime&gt;
#include&lt;memory&gt;
#include&lt;list&gt;//头文件其实不用开这么多，用万能库就行，不过我喜欢这样……
#define QWQ while(1)puts(&quot;(〃'▽'〃)&quot;)//忽略这行
using namespace std;
int a[1000001],b[1000001],ans[1000001],asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=max(ax.size(),bx.size())+1;i++)
	{
	    if(a[i]+b[i]&gt;=10)
	    {
	        a[i+1]++;
	        a[i]-=10;
	    }
	    ans[i]+=a[i]+b[i];
	}
	asl=max(ax.size(),bx.size())+1;
	while(ans[asl]!=0)asl++;
	asl--;
	for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
	return 0;
	QWQ;//这行也忽略
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度输出【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">
        </link>
        <updated>2020-02-26T05:05:43.000Z</updated>
        <content type="html"><![CDATA[<h4 id="高精度基本算法的通用输出">高精度基本算法的通用输出</h4>
<h5 id="非常的简单鸭">非常的简单鸭</h5>
<ul>
<li>假如我们的答案是12345，我们在ans数组里存它的时候就是这个样子：<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582693567222.png" alt="" loading="lazy"></li>
<li>所以我们要从ans[5]位向ans[1]位进行输出，在计算时我们已经求出了答案长度asl，这里asl=5，输出代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
</code></pre>
<ul>
<li>结束</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eon_Starlight]]></title>
        <id>https://eon-starlight.github.io/Blog/eon-de-keng/</id>
        <link href="https://eon-starlight.github.io/Blog/eon-de-keng/">
        </link>
        <updated>2020-02-25T11:45:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://eon-starlight.github.io/Blog//post-images/1582631686318.png" alt="" loading="lazy"></figure>
<h1 id="游荡于oi界于柴圈">游荡于oi界于柴圈……</h1>
<h1 id="一名蒻得很的蒟蒻">一名蒻得很的蒟蒻</h1>
<h1 id="菜是原罪啥都不会">菜是原罪，啥都不会</h1>
<p><img src="https://eon-starlight.github.io/Blog//post-images/1582631744762.png" alt="" loading="lazy"><br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582631753259.png" alt="" loading="lazy"><br>
###链接区域<br>
<a href="https://www.bilibili.com/"><img src="https://eon-starlight.github.io/Blog//post-images/1582675935541.png" alt="" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度读入【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">
        </link>
        <updated>2020-02-25T11:06:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="高精度基本算法的通用读入">高精度基本算法的通用读入</h3>
<ul>
<li>在普通实数变量型无法实现大数据运算时，我们会采用高精度来实现计算，我们利用数组来存一个数。要存多大的数就开多大的数组，因为我们用数组的每一个空间来存每一位数的那个数字。</li>
<li>假如要存12345这个数，要把它放进a[6]数组.我们把5放进a[1]，4放进a[2]，…，1放进a[5]。如下：</li>
</ul>
<pre><code class="language-cpp">a[1]=5;
a[2]=4;
a[3]=3
a[4]=2;
a[5]=1;
//现在a数组变成了{5,4,3,2,1}，a[i]就表示第i位
</code></pre>
<ul>
<li>我们不会把数字一位一位读入，而是选择用字符串一口气读入，然后就可以知道长度（.size()）就可以用for循环将字符串转成数组。</li>
<li>先度入：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
</code></pre>
<ul>
<li>然后这理解释一下字符串如何转数组。这里就以12345为例，先看一下代码：</li>
</ul>
<pre><code class="language-cpp">	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
<ul>
<li>为什么要这么写，我们来模拟一下。</li>
<li>首先i=ax.size()也就是五，然后将ax[ax.size-1]也就是ax[1]放进a[i]，具体怎么将字符转成数字百度一下，这里不解释了…<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629115230.png" alt="" loading="lazy"></li>
<li>i=4的情况<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629127550.png" alt="" loading="lazy"></li>
<li>3<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629136157.png" alt="" loading="lazy"></li>
<li>2<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629158832.png" alt="" loading="lazy"></li>
<li>1，像这样大家就应该明白了，已经很清晰了。<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629172963.png" alt="" loading="lazy"></li>
<li>读入就是这样，代码：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
]]></content>
    </entry>
</feed>
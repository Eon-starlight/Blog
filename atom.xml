<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://eon-starlight.github.io/Blog/</id>
    <title>Eon_Starlight&apos;s blog</title>
    <updated>2020-03-29T10:19:57.199Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://eon-starlight.github.io/Blog/"/>
    <link rel="self" href="https://eon-starlight.github.io/Blog/atom.xml"/>
    <subtitle>杀不死你的，终会使你更强大</subtitle>
    <logo>https://eon-starlight.github.io/Blog/images/avatar.png</logo>
    <icon>https://eon-starlight.github.io/Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Eon_Starlight&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[ 高精度基本减法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jian-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jian-fa-bi-ji/">
        </link>
        <updated>2020-03-29T10:18:50.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>不包括负数、小数（但可以输出负数）</li>
<li>
<h4 id="colorredcolorboxwhite读入"><a href="https://www.luogu.com.cn/blog/yx20070829/gao-jing-du-du-ru-bi-ji-post"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><menclose mathbackground="white"><mtext>读入</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\colorbox{white}{读入}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:red;height:1.2833299999999999em;background-color:white;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:red;"><span class="mord cjk_fallback" style="color:red;">读</span><span class="mord cjk_fallback" style="color:red;">入</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></h4>
</li>
<li>因为第二个数有可能比第一个数大，也就是有负数答案，所以我们需要判断一下是否是这样的情况。代码实现；</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
if((ax&lt;bx&amp;&amp;ax.size()==bx.size())||ax.size()&lt;bx.size())//判断
{
	swap(ax,bx);
	pd=1;
}
for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
//思路就是把a-b变成-(b-a),pd=1代表这种情况，pd=0就不是
</code></pre>
<ul>
<li>整体思路与高精度加法差不多，都是依据小学数学进行模拟</li>
<li>
<h4 id="colorredcolorboxwhite高精度加法链接"><a href="https://www.luogu.com.cn/blog/yx20070829/gao-jing-du-ji-ben-jia-fa-bi-ji-post"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><menclose mathbackground="white"><mtext>高精度加法链接</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\colorbox{white}{高精度加法链接}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:red;height:1.2833299999999999em;background-color:white;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:red;"><span class="mord cjk_fallback" style="color:red;">高</span><span class="mord cjk_fallback" style="color:red;">精</span><span class="mord cjk_fallback" style="color:red;">度</span><span class="mord cjk_fallback" style="color:red;">加</span><span class="mord cjk_fallback" style="color:red;">法</span><span class="mord cjk_fallback" style="color:red;">链</span><span class="mord cjk_fallback" style="color:red;">接</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></h4>
</li>
<li>具体见代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=1;i&lt;=max(ax.size(),bx.size());i++)
{
	if(a[i]&lt;b[i])
	{
		a[i+1]--;//向高位借位，这个绝不能放在ans上跟高精加法的原因一样。
		a[i]+=10;//借过来的位
	}
	ans[i]=a[i]-b[i];
}
</code></pre>
<ul>
<li>然后要计算答案长度，跟高精加法差不多：</li>
</ul>
<pre><code class="language-cpp">asl=max(ax.size(),bx.size());
while(ans[asl]==0)asl--;
</code></pre>
<ul>
<li>输出需要看一下pd，是否输出负号，所以要加一句代码：</li>
</ul>
<pre><code class="language-cpp">if(pd==1)printf(&quot;-&quot;);
</code></pre>
<ul>
<li>
<h4 id="colorredcolorboxwhite输出"><a href="https://www.luogu.com.cn/blog/yx20070829/gao-jing-du-shu-chu-bi-ji-post"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><menclose mathbackground="white"><mtext>输出</mtext></menclose></mstyle></mrow><annotation encoding="application/x-tex">\color{red}\colorbox{white}{输出}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2833299999999999em;vertical-align:-0.3em;"></span><span class="mord" style="color:red;"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9833299999999998em;"><span style="top:-2.98333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="stretchy colorbox" style="color:red;height:1.2833299999999999em;background-color:white;"></span></span><span style="top:-3.28333em;"><span class="pstrut" style="height:3.28333em;"></span><span class="mord boxpad" style="color:red;"><span class="mord cjk_fallback" style="color:red;">输</span><span class="mord cjk_fallback" style="color:red;">出</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3em;"><span></span></span></span></span></span></span></span></span></a></h4>
</li>
<li>最后在输出之后要特判一下，bug原因：</li>
</ul>
<pre><code class="language-cpp">if(asl&lt;1)printf(&quot;0&quot;);
</code></pre>
<ul>
<li>完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;//万能库
using namespace std;
int a[10087],b[10087],ans[10087],pd,asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	if((ax&lt;bx&amp;&amp;ax.size()==bx.size())||ax.size()&lt;bx.size())
	{
		swap(ax,bx);
		pd=1;
	}
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=max(ax.size(),bx.size());i++)
	{
		if(a[i]&lt;b[i])
		{
			a[i+1]--;
			a[i]+=10;
		}
		ans[i]=a[i]-b[i];
	}
	asl=max(ax.size(),bx.size());
	while(ans[asl]==0)asl--;
	if(pd==1)printf(&quot;-&quot;);
	for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
	if(asl&lt;1)printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度基本加法【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-ji-ben-jia-fa-bi-ji/">
        </link>
        <updated>2020-02-26T05:13:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>不包括负数、小数</li>
<li>
<h4 id="读入"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">读入</a></h4>
</li>
<li>首先以15463和23521为例数来进行模拟加法，如下图<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/llfbhk54.png" alt="QAQ" loading="lazy"></li>
<li>由此可见，每一位与每一位直接相加传进答案，也就是：</li>
</ul>
<pre><code class="language-cpp">ans[i]=a[i]+b[i];
//代码实现
</code></pre>
<h2 id="但是这没有考虑进位qaq">但是这没有考虑进位！！QAQ</h2>
<ul>
<li>那要怎么解决呢？可以根据小学知识来看把进的位加到下一位，就是低位-10，高位+10，代码实现：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	ans[i+1]++;
	a[i]-=10;//不用担心变成负数，加上b[i]总会≥0
}
ans[i]+=a[i]+b[i];
//这是对第i位的处理
</code></pre>
<ul>
<li>
<h3 id="注意进的位加到ans数组上了正常来说这不对会有解释">注意进的位加到ans数组上了，正常来说这不对，会有解释。</h3>
</li>
<li>我们再举个例子13425和15718：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/6k5jlze9.png" alt="QAQ" loading="lazy"></li>
<li>
<h3 id="在这个时候会出现问题举个例子就明白了">在这个时候会出现问题，举个例子就明白了。</h3>
</li>
<li>15555和14545：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/h1f46plz.png" alt="QAQ" loading="lazy"></li>
<li>因为我们把进的一位加到ans数组上了，然而我们无法判断ans[i]是否要进位，所以就出现了这种情况。</li>
<li>为了避免这种情况我们进的位加到a数组里见代码：</li>
</ul>
<pre><code class="language-cpp">if(a[i]+b[i]&gt;=10)
{
	a[i+1]++;
	a[i]-=10;
}
ans[i]+=a[i]+b[i];
</code></pre>
<ul>
<li>这就是正确的计算过程。为了方便输出我们要算出答案的长度，长度最低为asl=max(ax.size(),bx.size);（输入的ax和bx）。因为有进位的可能所以我们要维护一下：</li>
</ul>
<pre><code class="language-cpp">while(ans[asl]!=0)asl++;
//就是枚举到最高位
asl--;
//但是这样会多出来1，就减掉
</code></pre>
<ul>
<li>
<h4 id="输出"><a href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">输出</a></h4>
</li>
<li>完整代码：</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;//万能库
using namespace std;
int a[1000001],b[1000001],ans[1000001],asl;
string ax,bx;
int main()
{
	cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
	for(int i=1;i&lt;=max(ax.size(),bx.size())+1;i++)
	{
	    if(a[i]+b[i]&gt;=10)
	    {
	        a[i+1]++;
	        a[i]-=10;
	    }
	    ans[i]+=a[i]+b[i];
	}
	asl=max(ax.size(),bx.size())+1;
	while(ans[asl]!=0)asl++;
	asl--;
	for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度输出【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-shu-chu-bi-ji/">
        </link>
        <updated>2020-02-26T05:05:43.000Z</updated>
        <content type="html"><![CDATA[<h4 id="高精度基本算法的通用输出">高精度基本算法的通用输出</h4>
<h5 id="非常的简单鸭">非常的简单鸭</h5>
<ul>
<li>假如我们的答案是12345，我们在ans数组里存它的时候就是这个样子：<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582693567222.png" alt="" loading="lazy"></li>
<li>所以我们要从ans[5]位向ans[1]位进行输出，在计算时我们已经求出了答案长度asl，这里asl=5，输出代码：</li>
</ul>
<pre><code class="language-cpp">for(int i=asl;i&gt;0;i--)printf(&quot;%d&quot;,ans[i]);
</code></pre>
<ul>
<li>结束</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eon_Starlight]]></title>
        <id>https://eon-starlight.github.io/Blog/eon-de-keng/</id>
        <link href="https://eon-starlight.github.io/Blog/eon-de-keng/">
        </link>
        <updated>2020-02-25T11:45:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://eon-starlight.github.io/Blog//post-images/1582631686318.png" alt="" loading="lazy"></figure>
<h1 id="游荡于oi界于柴圈">游荡于oi界于柴圈……</h1>
<h1 id="一名蒻得很的蒟蒻">一名蒻得很的蒟蒻</h1>
<h1 id="菜是原罪啥都不会">菜是原罪，啥都不会</h1>
<p><img src="https://eon-starlight.github.io/Blog//post-images/1582631744762.png" alt="" loading="lazy"><br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582631753259.png" alt="" loading="lazy"><br>
###链接区域<br>
<a href="https://www.bilibili.com/"><img src="https://eon-starlight.github.io/Blog//post-images/1582675935541.png" alt="" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度读入【笔记】]]></title>
        <id>https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/</id>
        <link href="https://eon-starlight.github.io/Blog/gao-jing-du-du-ru-bi-ji/">
        </link>
        <updated>2020-02-25T11:06:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="高精度基本算法的通用读入">高精度基本算法的通用读入</h3>
<ul>
<li>在普通实数变量型无法实现大数据运算时，我们会采用高精度来实现计算，我们利用数组来存一个数。要存多大的数就开多大的数组，因为我们用数组的每一个空间来存每一位数的那个数字。</li>
<li>假如要存12345这个数，要把它放进a[6]数组.我们把5放进a[1]，4放进a[2]，…，1放进a[5]。如下：</li>
</ul>
<pre><code class="language-cpp">a[1]=5;
a[2]=4;
a[3]=3
a[4]=2;
a[5]=1;
//现在a数组变成了{5,4,3,2,1}，a[i]就表示第i位
</code></pre>
<ul>
<li>我们不会把数字一位一位读入，而是选择用字符串一口气读入，然后就可以知道长度（.size()）就可以用for循环将字符串转成数组。</li>
<li>先度入：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
</code></pre>
<ul>
<li>然后这理解释一下字符串如何转数组。这里就以12345为例，先看一下代码：</li>
</ul>
<pre><code class="language-cpp">	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
<ul>
<li>为什么要这么写，我们来模拟一下。</li>
<li>首先i=ax.size()也就是五，然后将ax[ax.size-1]也就是ax[1]放进a[i]，具体怎么将字符转成数字百度一下，这里不解释了…<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629115230.png" alt="" loading="lazy"></li>
<li>i=4的情况<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629127550.png" alt="" loading="lazy"></li>
<li>3<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629136157.png" alt="" loading="lazy"></li>
<li>2<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629158832.png" alt="" loading="lazy"></li>
<li>1，像这样大家就应该明白了，已经很清晰了。<br>
<img src="https://eon-starlight.github.io/Blog//post-images/1582629172963.png" alt="" loading="lazy"></li>
<li>读入就是这样，代码：</li>
</ul>
<pre><code class="language-cpp">cin&gt;&gt;ax&gt;&gt;bx;
	for(int i=ax.size();i&gt;0;i--)a[i]=ax[ax.size()-i]-'0';
	for(int i=bx.size();i&gt;0;i--)b[i]=bx[bx.size()-i]-'0';
</code></pre>
]]></content>
    </entry>
</feed>